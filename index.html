<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Junk Bot Adventure</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #222;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: #000;
      border: 1px solid #fff;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="400"></canvas>
  <script>
    // ------------------------------
    // 1. SETUP: Canvas, Context & Global Variables
    // ------------------------------
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // We'll use a state machine for the UI:
    // "start" = start/home screen; "playing" = game in progress; "gameover" = game over screen
    let gameState = "start";
    let gamePaused = false;

    // Key tracking
    const keys = {};

    // Score, gear threshold, etc.
    let score = 0;
    const requiredScoreForClaw = 50;
    let gears = [];       // Array of gear objects
    let platforms = [];   // Array of platform objects
    let claw = null;      // The claw hazard

    // ------------------------------
    // 2. LOAD ASSETS
    // ------------------------------

    // Background image – junkyard.jpeg
    const bgImage = new Image();
    bgImage.crossOrigin = "anonymous";
    bgImage.src = "junkyard.jpg";  // Place your junkyard.jpeg in images folder
    let bgImageLoaded = false;
    bgImage.onload = () => { bgImageLoaded = true; };
    bgImage.onerror = () => { console.error("Failed to load background image."); };

    // Junk Bot sprite – junkbot.png
    const junkBotImg = new Image();
    junkBotImg.crossOrigin = "anonymous";
    junkBotImg.src = "junkbot.png";   // Place your junkbot.png in images folder
    let junkBotImgLoaded = false;
    junkBotImg.onload = () => { junkBotImgLoaded = true; };
    junkBotImg.onerror = () => { console.error("Failed to load Junk Bot image."); };

    // Gear image – gear-black.png (used for all gears)
    const gearImg = new Image();
    gearImg.crossOrigin = "anonymous";
    gearImg.src = "gear-black.png";  // Place your gear-black.png in images folder
    let gearImgLoaded = false;
    gearImg.onload = () => { gearImgLoaded = true; };
    gearImg.onerror = () => { console.error("Failed to load Gear image."); };

    // Sound effects
    const jumpSound   = new Audio("https://actions.google.com/sounds/v1/cartoon/boing.ogg");
    const gearSound   = new Audio("https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg");
    const damageSound = new Audio("https://actions.google.com/sounds/v1/cartoon/pop.ogg");
    const clawSound   = new Audio("https://actions.google.com/sounds/v1/cartoon/clang.ogg");

    // ------------------------------
    // 3. GAME CLASSES
    // ------------------------------

    // Junk Bot (Player) Class
    class JunkBot {
      constructor() {
        this.reset();
      }
      reset() {
        this.x = 50;
        this.y = canvas.height - 70;
        this.width = 50;
        this.height = 50;
        this.velX = 0;
        this.velY = 0;
        this.speed = 5;
        this.jumpForce = 15;
        this.grounded = false;
        this.hearts = 15;
        this.magnetStrength = 0;
      }
      update() {
        // Horizontal movement
        if (keys["ArrowRight"]) {
          this.velX = this.speed;
        } else if (keys["ArrowLeft"]) {
          this.velX = -this.speed;
        } else {
          this.velX = 0;
        }
        // Jumping
        if (keys["ArrowUp"] && this.grounded) {
          this.velY = -this.jumpForce;
          this.grounded = false;
          jumpSound.currentTime = 0;
          jumpSound.play();
        }
        // Gravity & update position
        this.velY += 0.8;
        this.x += this.velX;
        this.y += this.velY;

        // Collision with platforms
        this.grounded = false;
        for (let plat of platforms) {
          if (
            this.x < plat.x + plat.width &&
            this.x + this.width > plat.x &&
            this.y + this.height <= plat.y + plat.height &&
            this.y + this.height >= plat.y
          ) {
            this.y = plat.y - this.height;
            this.velY = 0;
            this.grounded = true;
          }
        }
        // Keep inside canvas
        if (this.x < 0) this.x = 0;
        if (this.x + this.width > canvas.width)
          this.x = canvas.width - this.width;
      }
      draw() {
        // Draw Junk Bot sprite if loaded; otherwise, use a fallback rectangle.
        if (junkBotImgLoaded) {
          ctx.drawImage(junkBotImg, this.x, this.y, this.width, this.height);
        } else {
          ctx.fillStyle = "teal";
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }
        // Draw HUD (health, score, magnet level)
        ctx.fillStyle = "red";
        ctx.font = "20px Arial";
        ctx.fillText(`Hearts: ${this.hearts}`, 10, 25);
        ctx.fillStyle = "yellow";
        ctx.fillText(`Score: ${score}`, 10, 50);
        ctx.fillStyle = "lightblue";
        ctx.fillText(`Magnet: ${this.magnetStrength}`, 10, 75);
      }
    }
    const junkBot = new JunkBot();

    // Gear Class
    // Uses gearImg and applies different canvas filters based on the type.
    class Gear {
      constructor(type, x, y) {
        this.type = type;  // "gray", "black", "white"
        this.x = x;
        this.y = y;
        this.radius = 15;  // Used as half the desired draw width/height
      }
      update() {
        // Magnet effect: if Junk Bot has magnet power and is near, pull gear toward Junk Bot.
        const dx = (junkBot.x + junkBot.width / 2) - this.x;
        const dy = (junkBot.y + junkBot.height / 2) - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (junkBot.magnetStrength > 0 && distance < 150) {
          this.x += dx * 0.02;
          this.y += dy * 0.02;
        }
      }
      draw() {
        if (!gearImgLoaded) return;
        ctx.save();
        // Use canvas filters to change color of the same gear image.
        if (this.type === "black") {
          ctx.filter = "none";
        } else if (this.type === "gray") {
          ctx.filter = "invert(50%)"; // 50% inverted: mid-gray
        } else if (this.type === "white") {
          ctx.filter = "invert(100%)"; // full inversion: white gear
        }
        // Draw gear image centered at (this.x, this.y)
        ctx.drawImage(gearImg, this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
        ctx.restore();
      }
    }

    // Claw Class – a hazard that drops every 50 points.
    class Claw {
      constructor() {
        this.x = junkBot.x + junkBot.width / 2;
        this.y = -50;
        this.width = 30;
        this.height = 50;
        this.active = true;
      }
      update() {
        if (this.active) {
          this.y += 4;
          if (this.y > canvas.height) {
            this.active = false;
          }
        }
      }
      draw() {
        if (this.active) {
          ctx.fillStyle = "darkgray";
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }
      }
    }

    // ------------------------------
    // 4. INITIALIZE GAME OBJECTS
    // ------------------------------

    // Set up platforms for Junk Bot to run and jump on.
    function initPlatforms() {
      platforms = [];
      // Ground platform
      platforms.push({ x: 0, y: canvas.height - 20, width: canvas.width, height: 20 });
      // Additional platforms
      platforms.push({ x: 200, y: 300, width: 150, height: 15 });
      platforms.push({ x: 450, y: 200, width: 150, height: 15 });
    }
    initPlatforms();

    // Reset game variables when starting a new game.
    function resetGame() {
      score = 0;
      gears = [];
      claw = null;
      junkBot.reset();
      initPlatforms();
      gamePaused = false;
    }

    // Spawn a random gear at intervals.
    function spawnRandomGear() {
      let rand = Math.random();
      let gearType;
      if (rand < 0.6) {
        gearType = "gray";
      } else if (rand < 0.8) {
        gearType = "black";
      } else {
        gearType = "white";
      }
      const x = Math.random() * (canvas.width - 40) + 20;
      const y = Math.random() * (canvas.height - 200) + 50;
      gears.push(new Gear(gearType, x, y));
    }
    // Begin spawning gears every 2 seconds.
    const gearInterval = setInterval(spawnRandomGear, 2000);

    // ------------------------------
    // 5. COLLISION DETECTION & GEAR COLLECTION
    // ------------------------------
    function circleRectCollision(circle, rect) {
      let distX = Math.abs(circle.x - rect.x - rect.width / 2);
      let distY = Math.abs(circle.y - rect.y - rect.height / 2);
      if (distX > (rect.width / 2 + circle.radius)) return false;
      if (distY > (rect.height / 2 + circle.radius)) return false;
      if (distX <= (rect.width / 2)) return true;
      if (distY <= (rect.height / 2)) return true;
      let dx = distX - rect.width / 2;
      let dy = distY - rect.height / 2;
      return (dx * dx + dy * dy <= (circle.radius * circle.radius));
    }
    function rectCircleCollision(rect, circle) {
      return circleRectCollision(circle, rect);
    }
    function checkGearCollection() {
      for (let i = gears.length - 1; i >= 0; i--) {
        let gear = gears[i];
        const junkBotRect = { x: junkBot.x, y: junkBot.y, width: junkBot.width, height: junkBot.height };
        const gearCircle = { x: gear.x, y: gear.y, radius: gear.radius };
        if (circleRectCollision(gearCircle, junkBotRect)) {
          if (gear.type === "gray") {
            score += 5;
            junkBot.magnetStrength += 1;
            gearSound.currentTime = 0;
            gearSound.play();
          } else if (gear.type === "black") {
            junkBot.hearts -= 1;
            damageSound.currentTime = 0;
            damageSound.play();
          } else if (gear.type === "white") {
            junkBot.hearts = Math.min(junkBot.hearts + 1, 15);
            gearSound.currentTime = 0;
            gearSound.play();
          }
          gears.splice(i, 1);
        }
      }
    }

    // ------------------------------
    // 6. GAME LOOP & UI STATES
    // ------------------------------
    function gameLoop() {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw background
      if (bgImageLoaded) {
        ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
      } else {
        ctx.fillStyle = "#444";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      // Based on the game state, render appropriate UI and/or update game objects.
      if (gameState === "start") {
        // -------------------------
        // Start / Home Screen
        // -------------------------
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "white";
        ctx.font = "40px Arial";
        ctx.fillText("Junk Bot Adventure", canvas.width / 2 - 180, canvas.height / 2 - 40);
        ctx.font = "20px Arial";
        ctx.fillText("Use arrow keys to move & jump", canvas.width / 2 - 130, canvas.height / 2);
        ctx.fillText("Collect gears to boost score and power", canvas.width / 2 - 160, canvas.height / 2 + 30);
        ctx.fillText("Beware the dropping claw every 50 points!", canvas.width / 2 - 160, canvas.height / 2 + 60);
        ctx.fillStyle = "yellow";
        ctx.fillText("Press Enter or Click to Start", canvas.width / 2 - 130, canvas.height / 2 + 120);
      } else if (gameState === "playing") {
        // -------------------------
        // Game Play
        // -------------------------
        if (!gamePaused) {
          // Update game objects
          junkBot.update();
          gears.forEach(gear => gear.update());
          if (claw) claw.update();
          checkGearCollection();

          // Claw event: spawn the claw when score is a multiple of requiredScoreForClaw and no claw is active
          if (score > 0 && score % requiredScoreForClaw === 0 && !claw) {
            clawSound.currentTime = 0;
            clawSound.play();
            claw = new Claw();
          }
          // Update claw collision with Junk Bot
          if (claw) {
            const junkBotRect = { x: junkBot.x, y: junkBot.y, width: junkBot.width, height: junkBot.height };
            const clawRect = { x: claw.x, y: claw.y, width: claw.width, height: claw.height };
            if (rectCircleCollision(clawRect, { x: junkBot.x + junkBot.width / 2, y: junkBot.y + junkBot.height / 2, radius: 20 })) {
              junkBot.hearts -= 1;
              damageSound.currentTime = 0;
              damageSound.play();
              claw.active = false;
              claw = null;
            }
            if (!claw.active) {
              claw = null;
            }
          }
          // Increase Junk Bot's speed every 100 points as a simple level-up effect
          if (score > 0 && score % 100 === 0) {
            junkBot.speed = 5 + Math.floor(score / 100);
          }
        }
        // Render game objects
        platforms.forEach(plat => {
          ctx.fillStyle = "sienna";
          ctx.fillRect(plat.x, plat.y, plat.width, plat.height);
        });
        junkBot.draw();
        gears.forEach(gear => gear.draw());
        if (claw) claw.draw();

        // Optionally display pause message
        if (gamePaused) {
          ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "white";
          ctx.font = "30px Arial";
          ctx.fillText("Paused", canvas.width / 2 - 50, canvas.height / 2);
        }
      } else if (gameState === "gameover") {
        // -------------------------
        // Game Over Screen
        // -------------------------
        ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "white";
        ctx.font = "40px Arial";
        ctx.fillText("Game Over", canvas.width / 2 - 100, canvas.height / 2 - 20);
        ctx.font = "20px Arial";
        ctx.fillText("Click to return to Home", canvas.width / 2 - 110, canvas.height / 2 + 20);
      }

      // Check for game over condition (if Junk Bot loses all hearts)
      if (junkBot.hearts <= 0 && gameState === "playing") {
        gameState = "gameover";
      }

      requestAnimationFrame(gameLoop);
    }

    // ------------------------------
    // 7. EVENT LISTENERS & STATE TRANSITIONS
    // ------------------------------
    // Keydown events for game state control and movement.
    window.addEventListener("keydown", e => {
      keys[e.key] = true;
      if (gameState === "start" && e.key === "Enter") {
        resetGame();
        gameState = "playing";
      }
      // In playing state, toggle pause with 'p' or 'P'
      if (gameState === "playing" && e.key.toLowerCase() === "p") {
        gamePaused = !gamePaused;
      }
    });
    window.addEventListener("keyup", e => {
      keys[e.key] = false;
    });
    // Allow mouse clicks to start the game from the start screen or return to home on game over.
    canvas.addEventListener("click", () => {
      if (gameState === "start") {
        resetGame();
        gameState = "playing";
      } else if (gameState === "gameover") {
        gameState = "start";
      }
    });

    // ------------------------------
    // 8. START THE GAME LOOP
    // ------------------------------
    // Ensure the game loop runs continuously even from the start screen.
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
