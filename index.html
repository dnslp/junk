<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Junk Bot Adventure</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #222;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: #000;
      border: 1px solid #fff;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="400"></canvas>
  <script>
    // -------------------------------------
    // 1. SETUP: Canvas, Context, & Globals
    // -------------------------------------
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    
    // Game states: "start", "playing", "gameover"
    let gameState = "start";
    let gamePaused = false;
    
    // Global variables for score and game objects
    let score = 0;
    const requiredScoreForClaw = 50;
    let gears = [];       // Array of Gear objects
    let platforms = [];   // Array of platform objects
    let claw = null;      // Claw hazard object
    
    // New: Projectiles array for shots
    let projectiles = [];
    // Global: track the last arrow direction (default "right")
    let lastDirection = "right";
    
    // Key tracking
    const keys = {};

    // -------------------------------------
    // 2. LOAD ASSETS
    // -------------------------------------
    // Background image: junkyard.jpeg
    const bgImage = new Image();
    bgImage.crossOrigin = "anonymous";
    bgImage.src = "junkyard.jpg"; // Update path if necessary
    let bgImageLoaded = false;
    bgImage.onload = () => { bgImageLoaded = true; };
    bgImage.onerror = () => { console.error("Failed to load background image."); };
    
    // Junk Bot sprite: junkbot.png
    const junkBotImg = new Image();
    junkBotImg.crossOrigin = "anonymous";
    junkBotImg.src = "junkbot.png"; // Update path if necessary
    let junkBotImgLoaded = false;
    junkBotImg.onload = () => { junkBotImgLoaded = true; };
    junkBotImg.onerror = () => { console.error("Failed to load Junk Bot image."); };
    
    // Gear asset: gear-black.png (used for all gears, recolored via filters)
    const gearImg = new Image();
    gearImg.crossOrigin = "anonymous";
    gearImg.src = "gear-black.png"; // Update path if necessary
    let gearImgLoaded = false;
    gearImg.onload = () => { gearImgLoaded = true; };
    gearImg.onerror = () => { console.error("Failed to load Gear image."); };

    // Sound effects (update URLs if desired)
    const jumpSound   = new Audio("https://actions.google.com/sounds/v1/cartoon/boing.ogg");
    const gearSound   = new Audio("https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg");
    const damageSound = new Audio("https://actions.google.com/sounds/v1/cartoon/pop.ogg");
    const clawSound   = new Audio("https://actions.google.com/sounds/v1/cartoon/clang.ogg");
    // New sounds for shooting and gear hit by projectiles
    const shootSound  = new Audio("https://actions.google.com/sounds/v1/alarms/beep_short.ogg");
    const happySound  = new Audio("https://actions.google.com/sounds/v1/cartoon/cowbell.ogg");
    const sadSound    = new Audio("https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg");

    // -------------------------------------
    // 3. GAME CLASSES
    // -------------------------------------
    // Junk Bot (Player) Class
    class JunkBot {
      constructor() { this.reset(); }
      reset() {
        this.x = 50;
        this.y = canvas.height - 70;
        this.width = 50;
        this.height = 50;
        this.velX = 0;
        this.velY = 0;
        this.speed = 5;
        this.jumpForce = 18;
        this.grounded = false;
        this.hearts = 15;
        this.magnetStrength = 0;
      }
      update() {
        // Movement (and update lastDirection for shooting)
        if (keys["ArrowRight"]) {
          this.velX = this.speed;
          lastDirection = "right";
        } else if (keys["ArrowLeft"]) {
          this.velX = -this.speed;
          lastDirection = "left";
        } else {
          this.velX = 0;
        }
        if (keys["ArrowUp"]) {
          lastDirection = "up";
        }
        if (keys["ArrowDown"]) {
          lastDirection = "down";
        }
        if (keys["ArrowUp"] && this.grounded) {
          this.velY = -this.jumpForce;
          this.grounded = false;
          jumpSound.currentTime = 0;
          jumpSound.play();
        }
        // Apply gravity
        this.velY += 0.8;
        this.x += this.velX;
        this.y += this.velY;
        // Collision with platforms
        this.grounded = false;
        for (let plat of platforms) {
          if (this.x < plat.x + plat.width &&
              this.x + this.width > plat.x &&
              this.y + this.height <= plat.y + plat.height &&
              this.y + this.height >= plat.y) {
            this.y = plat.y - this.height;
            this.velY = 0;
            this.grounded = true;
          }
        }
        // Constrain within canvas boundaries
        if (this.x < 0) this.x = 0;
        if (this.x + this.width > canvas.width)
          this.x = canvas.width - this.width;
      }
      draw() {
        if (junkBotImgLoaded) {
          ctx.drawImage(junkBotImg, this.x, this.y, this.width, this.height);
        } else {
          ctx.fillStyle = "teal";
          ctx.fillRect(this.x, this.y, this.width, this.height);
        }
        // Draw HUD: hearts, score, magnet level
        ctx.fillStyle = "red";
        ctx.font = "20px Arial";
        ctx.fillText(`Hearts: ${this.hearts}`, 10, 25);
        ctx.fillStyle = "yellow";
        ctx.fillText(`Score: ${score}`, 10, 50);
        ctx.fillStyle = "lightblue";
        ctx.fillText(`Magnet: ${this.magnetStrength}`, 10, 75);
      }
    }
    const junkBot = new JunkBot();

    // Gear Class (uses a single gear image with canvas filters)
    class Gear {
      constructor(type, x, y) {
        this.type = type; // "gray", "black", or "white"
        this.x = x;
        this.y = y;
        this.radius = 15;
      }
      update() {
        const dx = (junkBot.x + junkBot.width / 2) - this.x;
        const dy = (junkBot.y + junkBot.height / 2) - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (junkBot.magnetStrength > 0 && distance < 150) {
          this.x += dx * 0.02;
          this.y += dy * 0.02;
        }
      }
      draw() {
        if (!gearImgLoaded) return;
        ctx.save();
        if (this.type === "black") {
          ctx.filter = "none";
        } else if (this.type === "gray") {
          ctx.filter = "invert(50%)"; // mid-gray effect
        } else if (this.type === "white") {
          ctx.filter = "invert(100%)"; // white
        }
        ctx.drawImage(gearImg, this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
        ctx.restore();
      }
    }

    // Updated Claw Class: Draws a larger, triangular claw with a black outline.
    class Claw {
      constructor() {
        this.x = junkBot.x + junkBot.width / 2;
        this.y = -50;
        this.width = 45;  // Increased width
        this.height = 70; // Increased height
        this.active = true;
      }
      update() {
        if (this.active) {
          this.y += 4;
          if (this.y > canvas.height) { this.active = false; }
        }
      }
      draw() {
        if (this.active) {
          ctx.beginPath();
          ctx.moveTo(this.x, this.y);
          ctx.lineTo(this.x - this.width / 2, this.y + this.height);
          ctx.lineTo(this.x + this.width / 2, this.y + this.height);
          ctx.closePath();
          ctx.fillStyle = "darkgray";
          ctx.fill();
          ctx.lineWidth = 2;
          ctx.strokeStyle = "black";
          ctx.stroke();
        }
      }
    }

    // New: Projectile Class (for shooting)
    class Projectile {
      constructor(x, y, vx, vy) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.radius = 5;
      }
      update() {
        this.x += this.vx;
        this.y += this.vy;
      }
      draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = "orange";
        ctx.fill();
        ctx.closePath();
      }
    }

    // -------------------------------------
    // 4. INITIALIZE GAME OBJECTS
    // -------------------------------------
    function initPlatforms() {
      platforms = [];
      // Ground platform
      platforms.push({ x: 0, y: canvas.height - 20, width: canvas.width, height: 20 });
      // Additional platforms
      platforms.push({ x: 200, y: 300, width: 150, height: 15 });
      platforms.push({ x: 450, y: 200, width: 150, height: 15 });
    }
    initPlatforms();

    // Reset game variables when starting/restarting the game
    function resetGame() {
      score = 0;
      gears = [];
      claw = null;
      projectiles = [];
      junkBot.reset();
      initPlatforms();
      gamePaused = false;
    }

    // Spawn a random gear every 2 seconds
    function spawnRandomGear() {
      let rand = Math.random();
      let gearType;
      if (rand < 0.6) { gearType = "gray"; }
      else if (rand < 0.8) { gearType = "black"; }
      else { gearType = "white"; }
      const x = Math.random() * (canvas.width - 40) + 20;
      const y = Math.random() * (canvas.height - 200) + 50;
      gears.push(new Gear(gearType, x, y));
    }
    const gearInterval = setInterval(spawnRandomGear, 2000);

    // -------------------------------------
    // 5. COLLISION DETECTION & GEAR COLLECTION
    // -------------------------------------
    function circleRectCollision(circle, rect) {
      let distX = Math.abs(circle.x - rect.x - rect.width / 2);
      let distY = Math.abs(circle.y - rect.y - rect.height / 2);
      if (distX > (rect.width / 2 + circle.radius)) return false;
      if (distY > (rect.height / 2 + circle.radius)) return false;
      if (distX <= (rect.width / 2)) return true;
      if (distY <= (rect.height / 2)) return true;
      let dx = distX - rect.width / 2;
      let dy = distY - rect.height / 2;
      return (dx * dx + dy * dy <= (circle.radius * circle.radius));
    }
    function rectCircleCollision(rect, circle) {
      return circleRectCollision(circle, rect);
    }
    function checkGearCollection() {
      for (let i = gears.length - 1; i >= 0; i--) {
        let gear = gears[i];
        const junkBotRect = { x: junkBot.x, y: junkBot.y, width: junkBot.width, height: junkBot.height };
        const gearCircle = { x: gear.x, y: gear.y, radius: gear.radius };
        if (circleRectCollision(gearCircle, junkBotRect)) {
          if (gear.type === "gray") {
            score += 5;
            junkBot.magnetStrength += 1;
            gearSound.currentTime = 0;
            gearSound.play();
          } else if (gear.type === "black") {
            junkBot.hearts -= 1;
            damageSound.currentTime = 0;
            damageSound.play();
          } else if (gear.type === "white") {
            junkBot.hearts = Math.min(junkBot.hearts + 1, 15);
            gearSound.currentTime = 0;
            gearSound.play();
          }
          gears.splice(i, 1);
        }
      }
    }

    // New: Check collisions between projectiles and gears.
    function checkProjectileCollisions() {
      for (let i = projectiles.length - 1; i >= 0; i--) {
        let proj = projectiles[i];
        // Remove projectile if it leaves the canvas
        if (proj.x < 0 || proj.x > canvas.width || proj.y < 0 || proj.y > canvas.height) {
          projectiles.splice(i, 1);
          continue;
        }
        // Check collision with gears
        for (let j = gears.length - 1; j >= 0; j--) {
          let gear = gears[j];
          let dx = proj.x - gear.x;
          let dy = proj.y - gear.y;
          let distance = Math.sqrt(dx * dx + dy * dy);
          if (distance < proj.radius + gear.radius) {
            // Play sound based on gear type:
            if (gear.type === "black") {
              happySound.currentTime = 0;
              happySound.play();
            } else {
              sadSound.currentTime = 0;
              sadSound.play();
            }
            // Remove both projectile and gear on hit.
            gears.splice(j, 1);
            projectiles.splice(i, 1);
            break;
          }
        }
      }
    }

    // -------------------------------------
    // 6. GAME LOOP & UI RENDERING
    // -------------------------------------
    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw background (with fallback)
      if (bgImageLoaded) {
        ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
      } else {
        ctx.fillStyle = "#444";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
      
      if (gameState === "start") {
        // ----- Start / Home Screen -----
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "white";
        ctx.font = "40px Arial";
        ctx.fillText("Junk Bot Adventure", canvas.width / 2 - 180, canvas.height / 2 - 40);
        ctx.font = "20px Arial";
        ctx.fillText("Use arrow keys to move & jump", canvas.width / 2 - 130, canvas.height / 2);
        ctx.fillText("Collect gears to boost score and power", canvas.width / 2 - 160, canvas.height / 2 + 30);
        ctx.fillText("Press Space to shoot gears", canvas.width / 2 - 140, canvas.height / 2 + 60);
        ctx.fillText("Watch out for the claw hazard every 50 points!", canvas.width / 2 - 190, canvas.height / 2 + 90);
        ctx.fillStyle = "yellow";
        ctx.fillText("Press Enter or click to Start", canvas.width / 2 - 130, canvas.height / 2 + 140);
      } else if (gameState === "playing") {
        // ----- Gameplay -----
        if (!gamePaused) {
          junkBot.update();
          gears.forEach(gear => gear.update());
          if (claw) { claw.update(); }
          checkGearCollection();
          checkProjectileCollisions();
          
          // Update projectiles
          for (let i = projectiles.length - 1; i >= 0; i--) {
            let proj = projectiles[i];
            proj.update();
          }
          
          // Spawn the claw hazard when score meets threshold and no claw is active
          if (score > 0 && score % requiredScoreForClaw === 0 && !claw) {
            clawSound.currentTime = 0;
            clawSound.play();
            claw = new Claw();
          }
          if (claw) {
            const junkBotRect = { x: junkBot.x, y: junkBot.y, width: junkBot.width, height: junkBot.height };
            const clawRect = { x: claw.x, y: claw.y, width: claw.width, height: claw.height };
            if (rectCircleCollision(clawRect, { x: junkBot.x + junkBot.width / 2, y: junkBot.y + junkBot.height / 2, radius: 20 })) {
              junkBot.hearts -= 1;
              damageSound.currentTime = 0;
              damageSound.play();
              claw.active = false;
              claw = null;
            }
            if (!claw.active) { claw = null; }
          }
          if (score > 0 && score % 100 === 0) {
            junkBot.speed = 5 + Math.floor(score / 100);
          }
        }
        // Render gameplay objects:
        platforms.forEach(plat => {
          ctx.fillStyle = "sienna";
          ctx.fillRect(plat.x, plat.y, plat.width, plat.height);
        });
        junkBot.draw();
        gears.forEach(gear => gear.draw());
        if (claw) { claw.draw(); }
        // Draw projectiles
        projectiles.forEach(proj => proj.draw());
        // Optionally display pause overlay
        if (gamePaused) {
          ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "white";
          ctx.font = "30px Arial";
          ctx.fillText("Paused", canvas.width / 2 - 50, canvas.height / 2);
        }
      } else if (gameState === "gameover") {
        // ----- Game Over Screen -----
        ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "white";
        ctx.font = "40px Arial";
        ctx.fillText("Game Over", canvas.width / 2 - 100, canvas.height / 2 - 20);
        ctx.font = "20px Arial";
        ctx.fillText("Click the button below to return Home", canvas.width / 2 - 150, canvas.height / 2 + 10);
        // Draw Return Home button
        const btnX = canvas.width / 2 - 100;
        const btnY = canvas.height / 2 + 40;
        const btnW = 200;
        const btnH = 50;
        ctx.fillStyle = "#007BFF";
        ctx.fillRect(btnX, btnY, btnW, btnH);
        ctx.fillStyle = "white";
        ctx.font = "20px Arial";
        ctx.fillText("Return Home", btnX + 35, btnY + 30);
      }
      
      // Transition to game over if Junk Bot runs out of hearts
      if (junkBot.hearts <= 0 && gameState === "playing") {
        gameState = "gameover";
      }
      
      requestAnimationFrame(gameLoop);
    }

    // -------------------------------------
    // 7. EVENT LISTENERS & STATE TRANSITIONS
    // -------------------------------------
    window.addEventListener("keydown", e => {
      keys[e.key] = true;
      // Update lastDirection when arrow keys are pressed
      if (e.key === "ArrowRight") { lastDirection = "right"; }
      else if (e.key === "ArrowLeft") { lastDirection = "left"; }
      else if (e.key === "ArrowUp") { lastDirection = "up"; }
      else if (e.key === "ArrowDown") { lastDirection = "down"; }
      
      if (gameState === "start" && e.key === "Enter") {
        resetGame();
        gameState = "playing";
      }
      if (gameState === "playing" && e.key.toLowerCase() === "p") {
        gamePaused = !gamePaused;
      }
      // New: If Space bar is pressed during play, fire a projectile.
      if (gameState === "playing" && e.code === "Space") {
        // Determine projectile velocity based on lastDirection.
        const projSpeed = 10;
        let vx = 0, vy = 0;
        if (lastDirection === "left") { vx = -projSpeed; }
        else if (lastDirection === "right") { vx = projSpeed; }
        else if (lastDirection === "up") { vy = -projSpeed; }
        else if (lastDirection === "down") { vy = projSpeed; }
        // Default to right if lastDirection is somehow unset.
        if (vx === 0 && vy === 0) { vx = projSpeed; }
        // Create projectile starting from Junk Bot's center
        const startX = junkBot.x + junkBot.width / 2;
        const startY = junkBot.y + junkBot.height / 2;
        const proj = new Projectile(startX, startY, vx, vy);
        projectiles.push(proj);
        shootSound.currentTime = 0;
        shootSound.play();
      }
    });
    window.addEventListener("keyup", e => { keys[e.key] = false; });
    
    canvas.addEventListener("click", e => {
      const rect = canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      if (gameState === "start") {
        resetGame();
        gameState = "playing";
      } else if (gameState === "gameover") {
        // Check if click is inside the "Return Home" button
        const btnX = canvas.width / 2 - 100;
        const btnY = canvas.height / 2 + 40;
        const btnW = 200;
        const btnH = 50;
        if (clickX >= btnX && clickX <= btnX + btnW &&
            clickY >= btnY && clickY <= btnY + btnH) {
          gameState = "start";
          resetGame();
        }
      }
    });

    // -------------------------------------
    // 8. START THE GAME LOOP
    // -------------------------------------
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
